diff --git a/client/src/components/RichTextDescriptionField.tsx b/client/src/components/RichTextDescriptionField.tsx
index b3c0448aae6be8d63169ad97cef624ffbe62ce0c..865da1775a97fd29a6ea49ed8018f5af6aa091fe 100644
--- a/client/src/components/RichTextDescriptionField.tsx
+++ b/client/src/components/RichTextDescriptionField.tsx
@@ -19,79 +19,85 @@ import { useTranslation } from 'react-i18next';
 import { normalizeRichText, stripHtmlText } from '../utils/richText';
 
 interface RichTextDescriptionFieldProps {
   label: string;
   value: string;
   onChange: (value: string) => void;
   minHeight?: number;
 }
 
 type ToolbarCommand =
   | 'bold'
   | 'italic'
   | 'insertUnorderedList'
   | 'insertOrderedList'
   | 'createLink';
 
 const RichTextDescriptionField: React.FC<RichTextDescriptionFieldProps> = ({
   label,
   value,
   onChange,
   minHeight = 220,
 }) => {
   const { t } = useTranslation();
   const theme = useTheme();
   const editorRef = useRef<HTMLDivElement | null>(null);
+  const draftRef = useRef<string>('');
   const [isEditing, setIsEditing] = useState(false);
   const [draft, setDraft] = useState<string>(value || '');
 
+  // Mantén un ref con el draft para usarlo al inicializar el editor sin gatillar re-renderizados
+  useEffect(() => {
+    draftRef.current = draft;
+  }, [draft]);
+
   // Cuando NO estamos editando, mantén el draft sincronizado con value
   useEffect(() => {
     if (!isEditing) {
       setDraft(value || '');
     }
   }, [isEditing, value]);
 
   // Pintar el contenido inicial cuando NO estamos editando (modo lectura)
   useEffect(() => {
     if (!isEditing && editorRef.current) {
       editorRef.current.innerHTML = value || '';
     }
   }, [isEditing, value]);
   
   const initEditor = useCallback(() => {
-  if (editorRef.current) {
-    editorRef.current.innerHTML = draft || '';
-    editorRef.current.focus();
-  }
-}, [draft]); // Esto NO rompe el cursor porque solo se ejecuta cuando yo la llamo
+    if (editorRef.current) {
+      editorRef.current.innerHTML = draftRef.current || '';
+      editorRef.current.focus();
+    }
+  }, []);
 
-        useEffect(() => {
-      if (isEditing) {
-        initEditor();
-      }
-    }, [isEditing, initEditor]);
+  useEffect(() => {
+    if (isEditing) {
+      initEditor();
+    }
+  }, [isEditing, initEditor]);
 
   const toolbarItems = useMemo(
     () => [
       { command: 'bold' as ToolbarCommand, icon: <FormatBoldIcon fontSize="small" />, label: t('richText.bold') },
       { command: 'italic' as ToolbarCommand, icon: <FormatItalicIcon fontSize="small" />, label: t('richText.italic') },
       {
         command: 'insertUnorderedList' as ToolbarCommand,
         icon: <FormatListBulletedIcon fontSize="small" />,
         label: t('richText.bulletList'),
       },
       {
         command: 'insertOrderedList' as ToolbarCommand,
         icon: <FormatListNumberedIcon fontSize="small" />,
         label: t('richText.orderedList'),
       },
       { command: 'createLink' as ToolbarCommand, icon: <LinkIcon fontSize="small" />, label: t('richText.link') },
     ],
     [t],
   );
 
   const handleInput = useCallback(() => {
     const html = editorRef.current?.innerHTML ?? '';
     // Actualizamos el estado, pero ya NO reescribimos innerHTML desde ningún efecto
     setDraft(html);
   }, []);
