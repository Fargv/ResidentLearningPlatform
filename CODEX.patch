diff --git a/README.md b/README.md
index 61d919c9bbc32b8bb034ef269423cd54897243e1..9efb3d59b1ff2d9cf8dbce1bd6a5aef8b3497ea9 100644
--- a/README.md
+++ b/README.md
@@ -1,83 +1,83 @@
 # Plataforma de FormaciÃ³n en TecnologÃ­as del Robot da Vinci
 
 Este proyecto implementa una plataforma web completa para llevar el seguimiento del programa de formaciÃ³n en tecnologÃ­as del robot da Vinci para residentes de hospitales.
 
 ## CaracterÃ­sticas principales
 
 - Sistema de autenticaciÃ³n con diferentes roles (residentes, participantes, tutores, profesores, CSM y administradores)
  - Seguimiento del progreso de los residentes y participantes a travÃ©s de las diferentes fases del programa
- - ValidaciÃ³n de actividades por parte de los tutores e profesores
+ - ValidaciÃ³n de actividades por parte de los tutores y profesores
 ## Estructura del proyecto
 
 ```
 davinci-platform/
 â”œâ”€â”€ src/                    # Backend (Node.js, Express, MongoDB)
 â”‚   â”œâ”€â”€ config/             # ConfiguraciÃ³n del servidor
 â”‚   â”œâ”€â”€ controllers/        # Controladores de la API
 â”‚   â”œâ”€â”€ middleware/         # Middleware (autenticaciÃ³n, errores)
 â”‚   â”œâ”€â”€ models/             # Modelos de datos
 â”‚   â”œâ”€â”€ routes/             # Rutas de la API
 â”‚   â”œâ”€â”€ utils/              # Utilidades
 â”‚   â””â”€â”€ server.js           # Punto de entrada del servidor
 â”œâ”€â”€ client/                 # Frontend (React, TypeScript, Material-UI)
 â”‚   â”œâ”€â”€ public/             # Archivos estÃ¡ticos
 â”‚   â”œâ”€â”€ src/                # CÃ³digo fuente
 â”‚   â”‚   â”œâ”€â”€ components/     # Componentes reutilizables
 â”‚   â”‚   â”œâ”€â”€ context/        # Contextos de React (autenticaciÃ³n)
 â”‚   â”‚   â”œâ”€â”€ pages/          # PÃ¡ginas de la aplicaciÃ³n
 â”‚   â”‚   â”œâ”€â”€ App.tsx         # Componente principal
 â”‚   â”‚   â””â”€â”€ index.tsx       # Punto de entrada
 â”‚   â””â”€â”€ package.json        # Dependencias del frontend
 â”œâ”€â”€ test.sh                 # Script para pruebas
 â”œâ”€â”€ dev.sh                  # Script para desarrollo
 â”œâ”€â”€ deploy.sh               # Script para despliegue
 â”œâ”€â”€ DEPLOY.md               # Instrucciones de despliegue
 â”œâ”€â”€ MANUAL_USUARIO.md       # Manual de usuario
 â””â”€â”€ package.json            # Dependencias del backend
 ```
 
 ## TecnologÃ­as utilizadas
 
 ### Backend
 - Node.js
 - Express
 - MongoDB
 - JWT para autenticaciÃ³n
 - Bcrypt para encriptaciÃ³n de contraseÃ±as
 
 ### Frontend
 - React
 - TypeScript
 - Material-UI
 - React Router
 - Axios para peticiones HTTP
 
 ## InstalaciÃ³n y ejecuciÃ³n
 
 ### Requisitos previos
-- Node.js (v18 o superior)
+- Node.js (v20 o superior)
 - MongoDB (local o Atlas)
 
 ### InstalaciÃ³n
 1. Clonar el repositorio
 2. Instalar dependencias del backend: `npm install`
 3. Instalar dependencias del frontend: `cd client && npm install`
 4. Copiar `.env.example` a `.env` y completar los valores requeridos:
    - `MONGO_URI` con la cadena de conexiÃ³n a tu base de datos.
    - `CLIENT_ORIGIN` y `FRONTEND_URL` con la URL desde la que se servirÃ¡ el
      frontend (por ejemplo, `http://localhost:5173` en desarrollo).
    - `BREVO_API_KEY`, `BREVO_SENDER_EMAIL` y `BREVO_SENDER_NAME` siguiendo la
      guÃ­a de la secciÃ³n [ConfiguraciÃ³n de Brevo](#configuraciÃ³n-de-brevo-envÃ­o-de-correos).
 
 ### EjecuciÃ³n en desarrollo
 ```bash
 ./dev.sh
 ```
 El script determina automÃ¡ticamente la ruta del proyecto por lo que puede ejecutarse desde cualquier directorio.
 
 ### Pruebas
 ```bash
 ./test.sh
 ```
 Al igual que `dev.sh`, este script se puede ejecutar desde cualquier ubicaciÃ³n ya que calcula la raÃ­z del repositorio.
 
diff --git a/src/server.js b/src/server.js
index bdc69084501c1166058454d668b9ecd750844b6f..983fc40716d85501675255979857fcb1d9ff9850 100644
--- a/src/server.js
+++ b/src/server.js
@@ -21,56 +21,57 @@ const authRoutes = require('./routes/authRoutes');
 const userRoutes = require('./routes/userRoutes');
 const hospitalRoutes = require('./routes/hospitalRoutes');
 const faseRoutes = require('./routes/faseRoutes');
 const actividadRoutes = require('./routes/actividadRoutes');
 const faseSocRoutes = require('./routes/faseSocRoutes');
 const actividadSocRoutes = require('./routes/actividadSocRoutes');
 const progresoRoutes = require('./routes/progresoRoutes');
 const adjuntoRoutes = require('./routes/adjuntoRoutes');
 const notificacionRoutes = require('./routes/notificacionRoutes');
 const adminRoutes = require('./routes/adminRoutes');
 const sociedadesRoutes = require('./routes/sociedadesRoutes');
 const certificadoRoutes = require('./routes/certificadoRoutes');
 const accessCodeRoutes = require('./routes/accessCodeRoutes');
 const surgeryTypeRoutes = require('./routes/surgeryTypeRoutes');
 const informeCirugiasRoutes = require('./routes/informeCirugiasRoutes');
 const informesRoutes = require('./routes/informesRoutes');
 
 // Inicializar app
 const app = express();
 
 // Middlewares esenciales
 app.use(express.json());
 app.use(cookieParser());
 app.use(helmet());
 const clientOrigin = process.env.CLIENT_ORIGIN || 'https://residentlearningplatform.netlify.app';
-const allowedOrigins = [
+const allowedOrigins = Array.from(new Set([
   'http://localhost:3000',
   'http://localhost:5173',
   'https://residentlearningplatform.netlify.app',
   'https://academicprogramdavinci.netlify.app',
-];
+  clientOrigin,
+]));
 
 const corsOptions = {
   origin: function (origin, callback) {
     if (!origin || allowedOrigins.includes(origin)) {
       callback(null, true);
     } else {
       console.warn(`ðŸ›‘ CORS bloqueado para origen: ${origin}`);
       callback(new Error(`CORS bloqueado: ${origin} no estÃ¡ en la lista de permitidos`));
     }
   },
   credentials: true,
 };
 
 app.use(cors(corsOptions));
 app.options('*', cors(corsOptions)); // Preflight para todos los endpoints
 app.use(fileupload());
 
 // Middleware de desarrollo
 if (process.env.NODE_ENV === 'development') {
   app.use(morgan('dev'));
 }
 
 // Directorio pÃºblico
 app.use(express.static(path.join(__dirname, '../public')));
 
diff --git a/tests/updatePhaseStatus.test.js b/tests/updatePhaseStatus.test.js
index 2741b0a6ddf7c9977039d2cfd21458941760d513..94538d12039b62dc203661fce006d69cc10f900a 100644
--- a/tests/updatePhaseStatus.test.js
+++ b/tests/updatePhaseStatus.test.js
@@ -12,50 +12,74 @@ describe('updatePhaseStatus', () => {
     const progreso = {
       actividades: [ { estado: 'validado' }, { estado: 'validado' } ],
       estadoGeneral: 'en progreso',
       residente: { _id: 'res1' },
       fase: { _id: 'fase1', orden: 1 },
       save: jest.fn(),
       populate: jest.fn().mockResolvedValue()
     };
 
     const nextFase = { _id: 'fase2', orden: 2 };
     const nextProgreso = {
       estadoGeneral: 'bloqueada',
       save: jest.fn()
     };
 
     jest.spyOn(Fase, 'findOne').mockResolvedValue(nextFase);
     jest.spyOn(ProgresoResidente, 'findOne').mockResolvedValue(nextProgreso);
 
     await updatePhaseStatus(progreso);
 
     expect(progreso.estadoGeneral).toBe('validado');
     expect(progreso.save).toHaveBeenCalled();
     expect(nextProgreso.estadoGeneral).toBe('en progreso');
     expect(nextProgreso.save).toHaveBeenCalled();
   });
+
+  test('does not update when there are activities pending validation', async () => {
+    const progreso = {
+      actividades: [
+        { estado: 'validado' },
+        { estado: 'pendiente' }
+      ],
+      estadoGeneral: 'en progreso',
+      residente: { _id: 'res1', email: 'residente@example.com' },
+      fase: { _id: 'fase1', orden: 1, nombre: 'Fase 1' },
+      save: jest.fn(),
+      populate: jest.fn().mockResolvedValue()
+    };
+
+    const faseSpy = jest.spyOn(Fase, 'findOne').mockResolvedValue(null);
+    const progresoSpy = jest.spyOn(ProgresoResidente, 'findOne').mockResolvedValue(null);
+
+    await updatePhaseStatus(progreso);
+
+    expect(progreso.save).not.toHaveBeenCalled();
+    expect(faseSpy).not.toHaveBeenCalled();
+    expect(progresoSpy).not.toHaveBeenCalled();
+  });
+
   test('uses FaseSoc when progreso.faseModel es FaseSoc', async () => {
     const progreso = {
       actividades: [{ estado: 'validado' }, { estado: 'validado' }],
       estadoGeneral: 'en progreso',
       residente: { _id: 'res1' },
       faseModel: 'FaseSoc',
       fase: { _id: 'soc1', orden: 1 },
       save: jest.fn(),
       populate: jest.fn().mockResolvedValue()
     };
 
     const nextFase = { _id: 'soc2', orden: 2 };
     const nextProgreso = {
       estadoGeneral: 'bloqueada',
       save: jest.fn()
     };
 
     const faseSpy = jest.spyOn(Fase, 'findOne');
     const faseSocSpy = jest.spyOn(FaseSoc, 'findOne').mockResolvedValue(nextFase);
     const progresoSpy = jest.spyOn(ProgresoResidente, 'findOne').mockResolvedValue(nextProgreso);
 
     await updatePhaseStatus(progreso);
 
     expect(faseSocSpy).toHaveBeenCalled();
     expect(faseSpy).not.toHaveBeenCalled();
