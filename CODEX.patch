diff --git a/tests/inviteUser.test.js b/tests/inviteUser.test.js
index 86d57827668ce75869dd307fdba866bd83aa9b0e..554f5ca20a63feb7fae69bbcc24028f8b2c74ee7 100644
--- a/tests/inviteUser.test.js
+++ b/tests/inviteUser.test.js
@@ -24,51 +24,53 @@ describe('inviteUser', () => {
     jest.spyOn(User, 'findOne').mockResolvedValue(null);
     jest.spyOn(Invitacion, 'findOne').mockResolvedValue(null);
     jest.spyOn(Hospital, 'findById').mockResolvedValue({ _id: 'h1' });
     const accessCode = { codigo: 'ABC123', rol: 'residente', tipo: 'Programa Residentes' };
     const accessSpy = jest.spyOn(AccessCode, 'findOne').mockResolvedValue(accessCode);
     const created = { _id: 'i1', email: 'new@test.com' };
     jest.spyOn(Invitacion, 'create').mockResolvedValue(created);
     sendEmail.mockResolvedValue();
 
     const req = {
       body: {
         email: 'new@test.com',
         rol: 'residente',
         hospital: 'h1',
         tipo: 'Programa Residentes'
       },
       protocol: 'http',
       get: () => 'localhost',
       user: { _id: 'admin', id: 'admin' },
       ip: '::1'
     };
     const res = { status: jest.fn().mockReturnThis(), json: jest.fn() };
 
     await inviteUser(req, res, jest.fn());
 
-    expect(Invitacion.create).toHaveBeenCalled();
+    expect(Invitacion.create).toHaveBeenCalledWith(
+      expect.objectContaining({ tipo: 'Programa Residentes' })
+    );
     expect(accessSpy).toHaveBeenCalledWith({ rol: 'residente', tipo: 'Programa Residentes' });
     expect(sendEmail).toHaveBeenCalled();
     expect(sendEmail).toHaveBeenCalledWith(
       expect.objectContaining({
         message: expect.stringContaining('Código de acceso: ABC123'),
         html: expect.stringContaining('ABC123')
       })
     );
     expect(res.status).toHaveBeenCalledWith(200);
     expect(res.json).toHaveBeenCalledWith({ success: true, data: created });
   });
 
   test('retorna error si el email existe', async () => {
     jest.spyOn(User, 'findOne').mockResolvedValue({ _id: 'u1' });
     const next = jest.fn();
 
     await inviteUser({ body: { email: 'taken@test.com' } }, {}, next);
 
     expect(next).toHaveBeenCalledWith(expect.any(ErrorResponse));
   });
 
   test('retorna error si no hay código configurado', async () => {
     jest.spyOn(User, 'findOne').mockResolvedValue(null);
     jest.spyOn(Invitacion, 'findOne').mockResolvedValue(null);
     jest.spyOn(Hospital, 'findById').mockResolvedValue({ _id: 'h1' });
diff --git a/tests/inviteUserCsm.test.js b/tests/inviteUserCsm.test.js
index 65a5c900b0513786da3c2628513b3c81fbf13eda..73890668fa8da8d8c4fadde2c1fcfbd9a02a2ef3 100644
--- a/tests/inviteUserCsm.test.js
+++ b/tests/inviteUserCsm.test.js
@@ -25,37 +25,37 @@ describe('inviteUser csm', () => {
     jest.spyOn(Hospital, 'findById').mockResolvedValue({ _id: 'h1' });
     const accessSpy = jest
       .spyOn(AccessCode, 'findOne')
       .mockResolvedValue({ codigo: 'CSM123', rol: 'csm', tipo: 'Programa Residentes' });
     const created = { _id: 'i1', email: 'coord@test.com', rol: 'csm' };
     jest.spyOn(Invitacion, 'create').mockResolvedValue(created);
     sendEmail.mockResolvedValue();
 
     const req = {
       body: {
         email: 'coord@test.com',
         rol: 'csm',
         hospital: 'h1',
         tipo: 'Programa Residentes'
       },
       protocol: 'http',
       get: () => 'localhost',
       user: { _id: 'admin', id: 'admin' },
       ip: '::1'
     };
     const res = { status: jest.fn().mockReturnThis(), json: jest.fn() };
 
     await inviteUser(req, res, jest.fn());
 
     expect(Invitacion.create).toHaveBeenCalledWith(
-      expect.objectContaining({ rol: 'csm' })
+      expect.objectContaining({ rol: 'csm', tipo: 'Programa Residentes' })
     );
     expect(accessSpy).toHaveBeenCalledWith({ rol: 'csm', tipo: 'Programa Residentes' });
     expect(sendEmail).toHaveBeenCalledWith(
       expect.objectContaining({
         message: expect.stringContaining('Código de acceso: CSM123')
       })
     );
     expect(res.status).toHaveBeenCalledWith(200);
     expect(res.json).toHaveBeenCalledWith({ success: true, data: created });
   });
 });
